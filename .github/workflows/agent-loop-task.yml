name: Agent Loop Task

# Triggered by repository_dispatch from agent-loop Edge Function
on:
  repository_dispatch:
    types: [agent-loop-task]

permissions:
  contents: write
  pull-requests: write

jobs:
  process:
    # Only run on actual repository_dispatch events (not push/PR)
    if: github.event_name == 'repository_dispatch'
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better context

      - name: Configure Git
        run: |
          git config user.name "Howler Agent"
          git config user.email "agent@howler.pages.dev"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Claude Code CLI
        run: npm install -g @anthropic-ai/claude-code

      - name: Run Claude Code
        id: claude
        env:
          # Priority: OAuth token (MAX subscription), fallback to API key
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          # Write prompt to file (avoids shell escaping issues)
          cat > /tmp/prompt.txt << 'PROMPT_EOF'
          ${{ github.event.client_payload.prompt }}
          PROMPT_EOF

          # Run Claude Code with JSON output to capture usage stats
          # --output-format json returns { result, usage, session_id, ... }
          # stderr separated to keep JSON clean on stdout
          # Build disallowedTools flag if set (prevents orchestrators from using inline sub-agents)
          DISALLOWED_TOOLS_FLAG=""
          if [ -n "${{ github.event.client_payload.disallowed_tools }}" ]; then
            DISALLOWED_TOOLS_FLAG="--disallowedTools ${{ github.event.client_payload.disallowed_tools }}"
          fi

          cat /tmp/prompt.txt | claude -p --output-format json --model ${{ github.event.client_payload.model || 'claude-opus-4-6' }} \
            --dangerously-skip-permissions $DISALLOWED_TOOLS_FLAG \
            > /tmp/output.json 2>/tmp/claude_stderr.txt || true

          # Extract text response from JSON (fallback to raw file if JSON parsing fails)
          if jq -e '.result' /tmp/output.json > /dev/null 2>&1; then
            jq -r '.result // empty' /tmp/output.json > /tmp/output.txt
          else
            echo "Warning: JSON parsing failed, using raw output" >&2
            cat /tmp/claude_stderr.txt > /tmp/output.txt 2>/dev/null || true
            cat /tmp/output.json >> /tmp/output.txt 2>/dev/null || true
          fi

          # Set response output
          echo "response<<EOF" >> $GITHUB_OUTPUT
          cat /tmp/output.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Extract accurate token usage from Claude Code's session JSONL logs.
      # The JSONL file is written incrementally, so it survives timeouts/kills.
      # Each assistant message has per-API-call usage with cache breakdowns.
      # This step runs ALWAYS (even on timeout) to capture usage from killed sessions.
      - name: Extract Session Usage
        if: always()
        id: usage
        run: |
          # Find the JSONL session file created during this run
          # Use -newer to only find files created after our prompt (avoids stale files)
          JSONL=$(find ~/.claude/projects/ -name "*.jsonl" -newer /tmp/prompt.txt 2>/dev/null | head -1)

          if [ -n "$JSONL" ] && [ -f "$JSONL" ]; then
            echo "Found session JSONL: $JSONL"

            # Sum all token types across all API calls in the session
            # input_tokens = non-cached new tokens
            # cache_creation_input_tokens = tokens written to cache
            # cache_read_input_tokens = tokens served from cache
            # Total input = all three combined (what was actually processed)
            USAGE=$(cat "$JSONL" | jq -c 'select(.type == "assistant") | .message.usage // empty' 2>/dev/null | jq -s '{
              input_tokens: (([.[].input_tokens // 0] | add) + ([.[].cache_creation_input_tokens // 0] | add) + ([.[].cache_read_input_tokens // 0] | add)),
              output_tokens: ([.[].output_tokens // 0] | add),
              cache_read_tokens: ([.[].cache_read_input_tokens // 0] | add),
              cache_creation_tokens: ([.[].cache_creation_input_tokens // 0] | add),
              num_api_calls: length
            }' 2>/dev/null)

            if [ -n "$USAGE" ] && [ "$USAGE" != "null" ]; then
              echo "input_tokens=$(echo "$USAGE" | jq -r '.input_tokens // 0')" >> $GITHUB_OUTPUT
              echo "output_tokens=$(echo "$USAGE" | jq -r '.output_tokens // 0')" >> $GITHUB_OUTPUT
              echo "cache_read_tokens=$(echo "$USAGE" | jq -r '.cache_read_tokens // 0')" >> $GITHUB_OUTPUT
              echo "cache_creation_tokens=$(echo "$USAGE" | jq -r '.cache_creation_tokens // 0')" >> $GITHUB_OUTPUT
              echo "num_api_calls=$(echo "$USAGE" | jq -r '.num_api_calls // 0')" >> $GITHUB_OUTPUT
              echo "Session usage extracted from JSONL ($(echo "$USAGE" | jq -r '.num_api_calls') API calls)"
            else
              echo "Warning: Failed to parse JSONL usage, falling back to JSON output"
              echo "input_tokens=0" >> $GITHUB_OUTPUT
              echo "output_tokens=0" >> $GITHUB_OUTPUT
              echo "cache_read_tokens=0" >> $GITHUB_OUTPUT
              echo "cache_creation_tokens=0" >> $GITHUB_OUTPUT
              echo "num_api_calls=0" >> $GITHUB_OUTPUT
            fi
          else
            echo "Warning: No JSONL session file found, falling back to JSON output"
            # Fallback: try to get from Claude Code JSON output (last-call only, but better than 0)
            echo "input_tokens=$(jq -r '.usage.input_tokens // 0' /tmp/output.json 2>/dev/null || echo 0)" >> $GITHUB_OUTPUT
            echo "output_tokens=$(jq -r '.usage.output_tokens // 0' /tmp/output.json 2>/dev/null || echo 0)" >> $GITHUB_OUTPUT
            echo "cache_read_tokens=0" >> $GITHUB_OUTPUT
            echo "cache_creation_tokens=0" >> $GITHUB_OUTPUT
            echo "num_api_calls=0" >> $GITHUB_OUTPUT
          fi

          # Get total_cost_usd from Claude Code JSON output (accurate session cost)
          echo "cost_usd=$(jq -r '.total_cost_usd // 0' /tmp/output.json 2>/dev/null || echo 0)" >> $GITHUB_OUTPUT

      # CRITICAL: Safety commit for any uncommitted files
      # GitHub Actions runners are ephemeral - files not committed are LOST
      # This runs even if Claude Code fails/times out, ensuring no work is lost
      - name: Safety Commit Uncommitted Files
        if: always()
        id: safety_commit
        run: |
          # Check if there are any uncommitted changes
          if [ -n "$(git status --porcelain)" ]; then
            echo "Found uncommitted files - creating safety commit"

            # Get current branch (may have been created by Claude)
            CURRENT_BRANCH=$(git branch --show-current)
            echo "branch=$CURRENT_BRANCH" >> $GITHUB_OUTPUT

            # Add all changes
            git add -A

            # Create safety commit with task ID for traceability
            TASK_ID="${{ github.event.client_payload.task_id }}"
            git commit -m "auto-save: uncommitted files from agent task

            Task ID: ${TASK_ID:0:8}
            Runner terminated before agent could commit these files.
            Review and integrate or clean up as needed."

            # Push to remote (create branch if needed)
            git push -u origin "$CURRENT_BRANCH" || {
              # If push fails (branch doesn't exist remotely), try with --set-upstream
              git push --set-upstream origin "$CURRENT_BRANCH"
            }

            echo "Safety commit pushed to branch: $CURRENT_BRANCH"
            echo "has_safety_commit=true" >> $GITHUB_OUTPUT
          else
            echo "No uncommitted files found"
            echo "has_safety_commit=false" >> $GITHUB_OUTPUT
            echo "branch=$(git branch --show-current)" >> $GITHUB_OUTPUT
          fi

      - name: Notify Webhook - Success
        if: success()
        env:
          WEBHOOK_URL: ${{ github.event.client_payload.webhook_url }}
          WEBHOOK_SECRET: ${{ secrets.HOWLER_AGENT_WEBHOOK_SECRET }}
          TASK_ID: ${{ github.event.client_payload.task_id }}
          RESPONSE: ${{ steps.claude.outputs.response }}
          BRANCH: ${{ steps.safety_commit.outputs.branch }}
          HAS_SAFETY_COMMIT: ${{ steps.safety_commit.outputs.has_safety_commit }}
          INPUT_TOKENS: ${{ steps.usage.outputs.input_tokens }}
          OUTPUT_TOKENS: ${{ steps.usage.outputs.output_tokens }}
          COST_USD: ${{ steps.usage.outputs.cost_usd }}
          CACHE_READ_TOKENS: ${{ steps.usage.outputs.cache_read_tokens }}
          CACHE_CREATION_TOKENS: ${{ steps.usage.outputs.cache_creation_tokens }}
        run: |
          # Build JSON payload using jq (includes token usage from session JSONL)
          # Write to file to ensure HMAC input and curl body are byte-identical
          # (avoids bash expansion issues with $, backticks, etc. in response text)
          jq -nc \
            --arg task_id "$TASK_ID" \
            --arg response "$RESPONSE" \
            --arg branch "$BRANCH" \
            --arg has_safety_commit "$HAS_SAFETY_COMMIT" \
            --argjson input_tokens "${INPUT_TOKENS:-0}" \
            --argjson output_tokens "${OUTPUT_TOKENS:-0}" \
            --argjson cost_usd "${COST_USD:-0}" \
            --argjson cache_read_tokens "${CACHE_READ_TOKENS:-0}" \
            --argjson cache_creation_tokens "${CACHE_CREATION_TOKENS:-0}" \
            '{
              task_id: $task_id,
              response: $response,
              status: "success",
              source: "github",
              branch: $branch,
              has_safety_commit: ($has_safety_commit == "true"),
              usage: {
                input_tokens: $input_tokens,
                output_tokens: $output_tokens,
                cost_usd: $cost_usd,
                cache_read_tokens: $cache_read_tokens,
                cache_creation_tokens: $cache_creation_tokens,
                model: "${{ github.event.client_payload.model || 'claude-opus-4-6' }}"
              }
            }' > /tmp/payload.json

          # Compute HMAC-SHA256 signature from the file
          SIGNATURE=$(openssl dgst -sha256 -hmac "$WEBHOOK_SECRET" /tmp/payload.json | awk '{print $NF}')

          curl -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -H "X-Hub-Signature-256: sha256=$SIGNATURE" \
            --data-binary @/tmp/payload.json

          echo "Notified webhook of successful execution"

      - name: Notify Webhook - Failure
        if: failure()
        env:
          WEBHOOK_URL: ${{ github.event.client_payload.webhook_url }}
          WEBHOOK_SECRET: ${{ secrets.HOWLER_AGENT_WEBHOOK_SECRET }}
          TASK_ID: ${{ github.event.client_payload.task_id }}
          BRANCH: ${{ steps.safety_commit.outputs.branch }}
          HAS_SAFETY_COMMIT: ${{ steps.safety_commit.outputs.has_safety_commit }}
          INPUT_TOKENS: ${{ steps.usage.outputs.input_tokens }}
          OUTPUT_TOKENS: ${{ steps.usage.outputs.output_tokens }}
          COST_USD: ${{ steps.usage.outputs.cost_usd }}
          CACHE_READ_TOKENS: ${{ steps.usage.outputs.cache_read_tokens }}
          CACHE_CREATION_TOKENS: ${{ steps.usage.outputs.cache_creation_tokens }}
        run: |
          # Build JSON payload to file (byte-identical for HMAC and curl)
          jq -nc \
            --arg task_id "$TASK_ID" \
            --arg branch "$BRANCH" \
            --arg has_safety_commit "$HAS_SAFETY_COMMIT" \
            --argjson input_tokens "${INPUT_TOKENS:-0}" \
            --argjson output_tokens "${OUTPUT_TOKENS:-0}" \
            --argjson cost_usd "${COST_USD:-0}" \
            --argjson cache_read_tokens "${CACHE_READ_TOKENS:-0}" \
            --argjson cache_creation_tokens "${CACHE_CREATION_TOKENS:-0}" \
            '{
              task_id: $task_id,
              response: "GitHub Action failed. Check workflow logs for details.",
              status: "failure",
              source: "github",
              branch: $branch,
              has_safety_commit: ($has_safety_commit == "true"),
              usage: {
                input_tokens: $input_tokens,
                output_tokens: $output_tokens,
                cost_usd: $cost_usd,
                cache_read_tokens: $cache_read_tokens,
                cache_creation_tokens: $cache_creation_tokens,
                model: "${{ github.event.client_payload.model || 'claude-opus-4-6' }}"
              }
            }' > /tmp/payload.json

          SIGNATURE=$(openssl dgst -sha256 -hmac "$WEBHOOK_SECRET" /tmp/payload.json | awk '{print $NF}')

          curl -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -H "X-Hub-Signature-256: sha256=$SIGNATURE" \
            --data-binary @/tmp/payload.json || true

          echo "Notified webhook of failure"

      - name: Notify Webhook - Cancelled/Timeout
        if: cancelled()
        env:
          WEBHOOK_URL: ${{ github.event.client_payload.webhook_url }}
          WEBHOOK_SECRET: ${{ secrets.HOWLER_AGENT_WEBHOOK_SECRET }}
          TASK_ID: ${{ github.event.client_payload.task_id }}
          BRANCH: ${{ steps.safety_commit.outputs.branch }}
          HAS_SAFETY_COMMIT: ${{ steps.safety_commit.outputs.has_safety_commit }}
          INPUT_TOKENS: ${{ steps.usage.outputs.input_tokens }}
          OUTPUT_TOKENS: ${{ steps.usage.outputs.output_tokens }}
          COST_USD: ${{ steps.usage.outputs.cost_usd }}
          CACHE_READ_TOKENS: ${{ steps.usage.outputs.cache_read_tokens }}
          CACHE_CREATION_TOKENS: ${{ steps.usage.outputs.cache_creation_tokens }}
        run: |
          # Build JSON payload to file (byte-identical for HMAC and curl)
          jq -nc \
            --arg task_id "$TASK_ID" \
            --arg branch "$BRANCH" \
            --arg has_safety_commit "$HAS_SAFETY_COMMIT" \
            --argjson input_tokens "${INPUT_TOKENS:-0}" \
            --argjson output_tokens "${OUTPUT_TOKENS:-0}" \
            --argjson cost_usd "${COST_USD:-0}" \
            --argjson cache_read_tokens "${CACHE_READ_TOKENS:-0}" \
            --argjson cache_creation_tokens "${CACHE_CREATION_TOKENS:-0}" \
            '{
              task_id: $task_id,
              response: "Iteration timed out. Work committed to branch. Auto-continuing with fresh context.",
              status: "failure",
              source: "github",
              timed_out: true,
              branch: $branch,
              has_safety_commit: ($has_safety_commit == "true"),
              usage: {
                input_tokens: $input_tokens,
                output_tokens: $output_tokens,
                cost_usd: $cost_usd,
                cache_read_tokens: $cache_read_tokens,
                cache_creation_tokens: $cache_creation_tokens,
                model: "${{ github.event.client_payload.model || 'claude-opus-4-6' }}"
              }
            }' > /tmp/payload.json

          SIGNATURE=$(openssl dgst -sha256 -hmac "$WEBHOOK_SECRET" /tmp/payload.json | awk '{print $NF}')

          curl -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -H "X-Hub-Signature-256: sha256=$SIGNATURE" \
            --data-binary @/tmp/payload.json || true

          echo "Notified webhook of cancellation/timeout"
